---
description: Testing Guidelines
globs: tests/**/*.py
alwaysApply: false
---
# Testing Guidelines

**For test files:** Comprehensive testing practices for reliable code.

## Test Structure

- **Pure functional style** - always write tests using plain functions. Avoid class-based or OOP-style tests entirely unless a concrete technical requirement makes them unavoidable
- **One test file per implementation file** - a 1:1 ratio between test files and implementation files
- **Clear test names** - describe what is being tested and expected outcome

```python
# ✅ DO: Descriptive test name
def test_user_registration_with_valid_email_creates_user():
    # Test implementation

# ❌ DON'T: Vague test name
def test_user():
    # Test implementation
```

## Fixture Organization and conftest.py

- **Follow "Local when possible, shared when necessary" principle**
- **Move fixtures to conftest.py** when they are used by 2+ test modules
- **Keep fixtures in test files** when they are domain-specific or likely to change

### When to Move Fixtures to conftest.py

**✅ Move to conftest.py:**
- **Cross-module reuse**: Used by multiple test files across different domains
- **Fundamental patterns**: Core infrastructure like database session mocks
- **Stable APIs**: Utilities that won't change often
- **Generic helpers**: AsyncMock context managers, common mocks

```python
# ✅ DO: Shared fixtures in tests/conftest.py
class MockAsyncContextManager:
    """Reusable async context manager for mocking database sessions."""

    def __init__(self, session):
        self.session = session

    async def __aenter__(self):
        return self.session

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        pass

@pytest.fixture
def mock_session():
    """Create a mock async database session."""
    return AsyncMock()

@pytest.fixture
def session_maker(mock_session):
    """Create a session maker function that returns a context manager."""
    def _session_maker():
        return MockAsyncContextManager(mock_session)
    return _session_maker
```

**❌ Keep in test files:**
- **Domain-specific**: Test data tied to specific APIs or business logic
- **Frequent changes**: Fixtures that evolve with feature development
- **Complex setup**: Multi-step scenarios specific to test cases
- **Single-use fixtures**: Only needed by one test module

```python
# ✅ DO: Domain-specific fixtures in test files
@pytest.fixture
def user_data():
    return {"name": "John Beekeeper", "email": "john@example.com"}

@pytest.fixture
def mock_user(mocker):
    user = User(id=1, name="John", email="john@example.com")
    user.registered_at = mocker.MagicMock()
    return user

@pytest.fixture
def base_app():
    """Create a basic aiohttp application without database setup."""
    app = web.Application()
    app.router.add_post("/api/users", create_user)
    return app
```

### Fixture Composition Patterns

- **Build hierarchical fixtures**: Create composable fixtures that depend on each other
- **Separate concerns**: Split database setup from application setup from client creation
- **Use descriptive naming**: Make fixture purpose clear from the name

```python
# ✅ DO: Composable fixture hierarchy
@pytest.fixture
def base_app():
    """Basic aiohttp application with routes."""
    app = web.Application()
    app.router.add_post("/api/users", create_user)
    return app

@pytest.fixture
def app_with_db(base_app, session_maker):
    """Application with database configured."""
    base_app[db_key] = session_maker
    return base_app

@pytest.fixture
async def client(aiohttp_client, base_app):
    """Test client for validation-only tests."""
    return await aiohttp_client(base_app)

@pytest.fixture
async def client_with_db(aiohttp_client, app_with_db):
    """Test client with database configured."""
    return await aiohttp_client(app_with_db)
```

### Fixture Scope Strategy

- **Function scope** (default): For test data and mocks that should be fresh per test
- **Module scope**: For expensive setup that can be shared within a module
- **Session scope**: For very expensive resources shared across entire test suite

```python
# ✅ DO: Appropriate fixture scoping
@pytest.fixture(scope="session")
def expensive_resource():
    """Expensive setup shared across all tests."""
    return create_expensive_resource()

@pytest.fixture(scope="module")
def module_database():
    """Database setup shared within module."""
    return setup_test_database()

@pytest.fixture  # Default: scope="function"
def fresh_data():
    """Fresh data for each test."""
    return {"count": 0}
```

### DRY Principle in Test Fixtures

- **Extract common setup patterns** into reusable fixtures
- **Eliminate duplication** across test files without over-centralizing
- **Refactor repetitive test setup** into fixture composition

```python
# ❌ DON'T: Repetitive setup in every test
async def test_endpoint_success(aiohttp_client):
    app = web.Application()
    app[db_key] = session_maker
    app.router.add_post("/api/users", create_user)
    client = await aiohttp_client(app)
    # Test logic...

async def test_endpoint_failure(aiohttp_client):
    app = web.Application()
    app[db_key] = session_maker  # Duplicated!
    app.router.add_post("/api/users", create_user)  # Duplicated!
    client = await aiohttp_client(app)
    # Test logic...

# ✅ DO: Use composable fixtures
async def test_endpoint_success(client_with_db):
    # Test logic only...

async def test_endpoint_failure(client_with_db):
    # Test logic only...
```

## aiohttp Testing Patterns

- **Use aiohttp test client** - for integration testing web endpoints
- **Mock database sessions** - isolate business logic from data layer
- **Test middleware independently** - unit test middleware behavior

```python
# ✅ DO: aiohttp client testing
async def test_health_endpoint_returns_healthy_status(aiohttp_client):
    app = await create_app()
    client = await aiohttp_client(app)

    resp = await client.get("/health")

    assert resp.status == 200
    data = await resp.json()
    assert data["status"] == "healthy"

# ✅ DO: Mock database for handler testing
async def test_index_handler_with_db_error(aiohttp_client, mocker):
    mock_session = mocker.patch("cityhive.app.views.request.app")
    mock_session.side_effect = Exception("DB Error")

    app = await create_app()
    client = await aiohttp_client(app)

    resp = await client.get("/")
    assert resp.status == 200  # Should handle gracefully
```

## Test Organization

- **Arrange-Act-Assert pattern** clearly separated
- **Use fixtures** for setup/teardown instead of setUp/tearDown methods
- **Parametrize tests** to reduce duplication

```python
# ✅ DO: Use parametrize for multiple test cases
@pytest.mark.parametrize(
    "email,expected_valid",
    [
        ("user@example.com", True),
        ("invalid-email", False),
        ("", False),
    ],
)
def test_email_validation(email: str, expected_valid: bool):
    result = validate_email(email)
    assert result.is_valid is expected_valid

# ❌ DON'T:
def test_validation_function():
    assert validate_input("valid_input") is True
    assert validate_input("invalid_input") is False
    assert validate_input("another_case") is False
```

## Async Testing

- **Use async test functions** for testing async code
- **Proper await patterns** - await all async operations
- **Mock async functions** correctly with AsyncMock

```python
# ✅ DO: Async test function
async def test_async_database_operation():
    async with async_session() as session:
        result = await session.execute(select(User))
        users = result.scalars().all()
    assert len(users) >= 0

# ✅ DO: Mock async operations
async def test_user_creation_with_async_mock(mocker):
    mock_execute = mocker.patch("sqlalchemy.ext.asyncio.AsyncSession.execute")
    mock_execute.return_value = AsyncMock()

    result = await create_user(user_data)
    assert result.success
```

## Mock and Patch Strategy

- **Flatten nested context managers** using comma syntax

```python
# ✅ DO:
with patch("module.first_dependency", mock_value1), \
    patch("module.second_dependency", mock_value2), \
    patch("module.third_dependency", mock_value3):
    # Test code

# ❌ DON'T:
with patch("module.first_dependency", mock_value1):
    with patch("module.second_dependency", mock_value2):
        with patch("module.third_dependency", mock_value3):
            # Test code
```

- **Mock external dependencies** but not internal business logic
- **Use pytest-mock** for consistent mocking patterns

```python
# ✅ DO: Flat context managers
def test_user_service_with_dependencies(mocker):
    mock_db = mocker.patch("cityhive.infrastructure.database.get_session")
    mock_email = mocker.patch("cityhive.infrastructure.email.send_email")

    result = user_service.create_user(user_data)

    assert result.success
    mock_db.assert_called_once()
    mock_email.assert_called_once()
```

## Test Commands

- **Run all tests**: `uv run --frozen pytest ./tests`
- **Run specific test**: `uv run --frozen pytest ./tests/unit/infrastructure/test_config.py`
- **Run with coverage**: `uv run --frozen pytest --cov=cityhive`
- **Run only fast tests**: `uv run --frozen pytest -m "not slow"`
- **Test aiohttp app**: `uv run --frozen pytest ./tests/unit/app/`

## Test Markers

- **Mark slow tests**: `@pytest.mark.slow` for integration tests
- **Mark integration tests**: `@pytest.mark.integration`
- **Mark web tests**: `@pytest.mark.web` for aiohttp endpoint tests
- **Skip tests conditionally**: Use `@pytest.mark.skipif` with clear reason

## Test Quality

- **No comments in tests** - DO NOT add comments to tests. Tests should be understandable without comments. Refactor complex tests into smaller ones.
- **Break complex tests** into smaller, focused tests
- **All new features need tests** - no exceptions
- **Bug fixes need regression tests** - prevent reoccurrence

## Fixtures

- **Scope appropriately**: session, module, function based on needs
- **Use dependency injection**: pass fixtures as parameters
- **Clean setup/teardown**: ensure tests don't affect each other

```python
# ✅ DO: Well-scoped fixture
@pytest.fixture(scope="function")
def user_data():
    return {
        "email": "test@example.com",
        "name": "Test User",
        "age": 25
    }

# ✅ DO: aiohttp app fixture
@pytest.fixture
async def app():
    return await create_app()
```

---

**See also:**
- [python-standards.mdc](mdc:.cursor/rules/python-standards.mdc) for general Python conventions
- [Development Guide](mdc:docs/development.md) for test commands and setup
- [Architecture Guide](mdc:docs/architecture.md) for testing architecture patterns
- [CONTRIBUTING.md](mdc:CONTRIBUTING.md) for contribution and review process
