---
description: Testing Guidelines
globs: globs: **/test_*.py
alwaysApply: false
---
# Testing Guidelines

**For test files:** Comprehensive testing practices for reliable code.

## Test Structure

- **Pure functional style** - always write tests using plain functions. Avoid class-based or OOP-style tests entirely unless a concrete technical requirement makes them unavoidable
- **One test file per implementation file** - a 1:1 ratio between test files and implementation files
- **Clear test names** - describe what is being tested and expected outcome

```python
# ✅ DO: Descriptive test name
def test_user_registration_with_valid_email_creates_user():
    # Test implementation

# ❌ DON'T: Vague test name
def test_user():
    # Test implementation
```

## aiohttp Testing Patterns

- **Use aiohttp test client** - for integration testing web endpoints
- **Mock database sessions** - isolate business logic from data layer
- **Test middleware independently** - unit test middleware behavior

```python
# ✅ DO: aiohttp client testing
async def test_health_endpoint_returns_healthy_status(aiohttp_client):
    app = await create_app()
    client = await aiohttp_client(app)

    resp = await client.get("/health")

    assert resp.status == 200
    data = await resp.json()
    assert data["status"] == "healthy"

# ✅ DO: Mock database for handler testing
async def test_index_handler_with_db_error(aiohttp_client, mocker):
    mock_session = mocker.patch("cityhive.app.views.request.app")
    mock_session.side_effect = Exception("DB Error")

    app = await create_app()
    client = await aiohttp_client(app)

    resp = await client.get("/")
    assert resp.status == 200  # Should handle gracefully
```

## Test Organization

- **Arrange-Act-Assert pattern** clearly separated
- **Use fixtures** for setup/teardown instead of setUp/tearDown methods
- **Parametrize tests** to reduce duplication

```python
# ✅ DO: Use parametrize for multiple test cases
@pytest.mark.parametrize(
    "email,expected_valid",
    [
        ("user@example.com", True),
        ("invalid-email", False),
        ("", False),
    ],
)
def test_email_validation(email: str, expected_valid: bool):
    result = validate_email(email)
    assert result.is_valid is expected_valid

# ❌ DON'T:
def test_validation_function():
    assert validate_input("valid_input") is True
    assert validate_input("invalid_input") is False
    assert validate_input("another_case") is False
```

## Async Testing

- **Use async test functions** for testing async code
- **Proper await patterns** - await all async operations
- **Mock async functions** correctly with AsyncMock

```python
# ✅ DO: Async test function
async def test_async_database_operation():
    async with async_session() as session:
        result = await session.execute(select(User))
        users = result.scalars().all()
    assert len(users) >= 0

# ✅ DO: Mock async operations
async def test_user_creation_with_async_mock(mocker):
    mock_execute = mocker.patch("sqlalchemy.ext.asyncio.AsyncSession.execute")
    mock_execute.return_value = AsyncMock()

    result = await create_user(user_data)
    assert result.success
```

## Mock and Patch Strategy

- **Flatten nested context managers** using comma syntax

```python
# ✅ DO:
with patch("module.first_dependency", mock_value1), \
    patch("module.second_dependency", mock_value2), \
    patch("module.third_dependency", mock_value3):
    # Test code

# ❌ DON'T:
with patch("module.first_dependency", mock_value1):
    with patch("module.second_dependency", mock_value2):
        with patch("module.third_dependency", mock_value3):
            # Test code
```

- **Mock external dependencies** but not internal business logic
- **Use pytest-mock** for consistent mocking patterns

```python
# ✅ DO: Flat context managers
def test_user_service_with_dependencies(mocker):
    mock_db = mocker.patch("cityhive.infrastructure.database.get_session")
    mock_email = mocker.patch("cityhive.infrastructure.email.send_email")

    result = user_service.create_user(user_data)

    assert result.success
    mock_db.assert_called_once()
    mock_email.assert_called_once()
```

## Test Commands

- **Run all tests**: `uv run --frozen pytest ./tests`
- **Run specific test**: `uv run --frozen pytest ./tests/unit/infrastructure/test_config.py`
- **Run with coverage**: `uv run --frozen pytest --cov=cityhive`
- **Run only fast tests**: `uv run --frozen pytest -m "not slow"`
- **Test aiohttp app**: `uv run --frozen pytest ./tests/unit/app/`

## Test Markers

- **Mark slow tests**: `@pytest.mark.slow` for integration tests
- **Mark integration tests**: `@pytest.mark.integration`
- **Mark web tests**: `@pytest.mark.web` for aiohttp endpoint tests
- **Skip tests conditionally**: Use `@pytest.mark.skipif` with clear reason

## Test Quality

- **No comments in tests** - DO NOT add comments to tests. Tests should be understandable without comments. Refactor complex tests into smaller ones.
- **Break complex tests** into smaller, focused tests
- **All new features need tests** - no exceptions
- **Bug fixes need regression tests** - prevent reoccurrence

## Fixtures

- **Scope appropriately**: session, module, function based on needs
- **Use dependency injection**: pass fixtures as parameters
- **Clean setup/teardown**: ensure tests don't affect each other

```python
# ✅ DO: Well-scoped fixture
@pytest.fixture(scope="function")
def user_data():
    return {
        "email": "test@example.com",
        "name": "Test User",
        "age": 25
    }

# ✅ DO: aiohttp app fixture
@pytest.fixture
async def app():
    return await create_app()
```

---

**See also:**
- [python-standards.mdc](mdc:.cursor/rules/python-standards.mdc) for general Python conventions
- Pytest documentation for advanced patterns
