---
description: Describes project coding standards, code style requirements and project conventions
globs: **/*.py
alwaysApply: false
---
# Python Coding Standards & Project Conventions

This rule defines the required coding standards, style, and framework usage for all Python code in the repository.

---

## Python Version

- Use **Python 3.12** for all code in the repository.

## Frameworks and Tools

- Required frameworks and libraries:
  - Aiohttp
  - Pydantic
  - SQLAlchemy
  - Pytest
  - Coverage

ALWAYS use Context7 to get information about libraries, frameworks or patterns.

## Coding Style

1. **Use Meaningful Names**: Choose descriptive variable, function, and class names.
   ```python
   # ✅ DO:
   def calculate_total(price: float, tax: float) -> float:
       return price + tax
   # ❌ DON'T:
   def ct(p, t):
       return p + t
   ```
2. **Follow PEP 8**: Adhere to the Python Enhancement Proposal 8 style guide for formatting.
   - Use 4 spaces per indentation level.
3. **Use Docstrings**: Document functions and classes with docstrings using Google style.
   ```python
   def add(a: int, b: int) -> int:
       """Add two integers.

       Args:
           a (int): First integer.
           b (int): Second integer.

       Returns:
           int: The sum of a and b.
       """
       return a + b
   ```
4. **Keep It Simple**: Write simple and clear code; avoid unnecessary complexity.
5. **Use List Comprehensions**: Prefer list comprehensions for creating lists over traditional loops when appropriate.
   ```python
   # ✅ DO:
   squares = [x * x for x in range(10)]
   # ❌ DON'T:
   squares = []
   for x in range(10):
       squares.append(x * x)
   ```
6. **Handle Exceptions**: Use try-except blocks to handle exceptions gracefully.
   ```python
   try:
       result = 10 / divisor
   except ZeroDivisionError:
       logger.error("Division by zero.")
   ```
7. **Write Tests**:
   - Implement unit tests to ensure code reliability.
   - Always prefer pure functional pytests style over OOP with classes
   - To run all tests in particular service or package use `uv run --frozen pytest ./tests`
   - To run particular test module in a particular service or package use the following format `uv run --frozen pytest ./tests/unit/infrastructure/test_config.py`
   - All new features require tests; bug fixes need regression tests
   - DO NOT add comments to tests. Tests should be understandable without comments. Refactor complex tests into smaller ones.
   - Use pytest fixtures for clean setup/teardown instead of setUp()/tearDown()
   - Use `@pytest.mark.parametrize` for data-driven testing and to reduce repeated test code:
     ```python
     # ✅ DO:
     @pytest.mark.parametrize(
         "input_value,expected_result",
         [
             ("valid_input", True),
             ("invalid_input", False),
             ("another_case", False),
         ],
     )
     def test_validation_function(input_value, expected_result):
         assert validate_input(input_value) is expected_result

     # ❌ DON'T:
     def test_validation_function():
         assert validate_input("valid_input") is True
         assert validate_input("invalid_input") is False
         assert validate_input("another_case") is False
     ```
   - Avoid deep nesting of context managers:
     ```python
     # ✅ DO:
     with patch("module.first_dependency", mock_value1), \
          patch("module.second_dependency", mock_value2), \
          patch("module.third_dependency", mock_value3):
         # Test code

     # ❌ DON'T:
     with patch("module.first_dependency", mock_value1):
         with patch("module.second_dependency", mock_value2):
             with patch("module.third_dependency", mock_value3):
                 # Test code
     ```
   - Mark slow tests by `@pytest.mark.slow` for separate execution
   - Maintain a 1:1 ratio between test files and implementation files
   - Use pytest-mock for creating mocks and stubs
8. **Use Type Hints**: Utilize type hints for better code clarity and type checking. Prefer PEP 604 over PEP 484. Use PEP 585:
   ```python
   # ✅ DO:
   output_file: str | None = None
   violations: list[str]

   # ❌ DON'T:
   from typing import List, Optional

   output_file: Optional[str] = None
   violations: List[str]
   ```
9. **Avoid Global Variables**: Limit the use of global variables to reduce side effects.
10. **Use DRY**: Don't repeat yourself - use functions and classes to avoid duplication.
11. **Line Length**: Use 88 characters as a limit for line length.
12. **Follow Best Practices**: Follow best practices for Flask, Celery, SQLAlchemy, Pytest, etc.
13. **Logging**:
   Do not use print() for logging. Use Python's built-in logging module:
   ```python
   # ❌ DON'T:
   print("message")

   # ✅ DO:
   import logging
   logger = logging.getLogger(__name__)
   logger.info("Message")
   ```

   Avoid using f-strings to format logging messages:
   ```python
   # ❌ DON'T:
   logger.info(f"User {user_id} - Something happened")

   # ✅ DO:
   logger.info("User %s - Something happened", user_id)
   # Or, for structured logging:
   logger.info("Something happened", extra={"user_id": user_id})
   ```
14. **Comments**: Do not use obvious comments. The target audience is a senior Python developer.
   - **❌ DON'T:**
     ```python
     x = x + 1  # Increment x by 1
     result = calculate_total(price, tax)  # Call the function to calculate total
     for item in items:  # Loop through items
         print(item)
     ```
   - **✅ DO:**
     ```python
     # Use a custom rounding strategy to avoid floating point issues
     total = round(calculate_total(price, tax), 2)
     ```

---

**See also:**
- [project-structure.mdc](mdc:.cursor/rules/project-structure.mdc)
- [pyproject.toml](mdc:pyproject.toml)
- [docker-compose.yml](mdc:docker-compose.yml)
- [README.md](mdc:README.md)
- [CONTRIBUTING.md](mdc:CONTRIBUTING.md)
